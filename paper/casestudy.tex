\section{Case Study}

In order to evaluate the methodology, we applied the method and the tool on NetBeans IDE. NetBeans IDE is widely used among the developers and considered one of the popular development tools for java developers.  The main version of NetBeans IDE that we downloaded for our experiments consists of 7386809 non empty non commented lines of code. NetBeans IDE source code seems to be well tested with large number of unit tests, function tests and performance tests written for most of the modules. For As a stand alone tool, NetBeans IDE uses significant amount of resources like memory and cpu. For the study, we concentrate on memory as a resource and attempted to automatically build NetBeans IDE that can consume less memory.

Redo and undo are very common functionality used of NetBeans IDE, just like any other IDE. When any form of editing happens within the IDE, it has to be stored in order for undo-redo to work correctly. In order to preserve resources, NetBeans IDE limits undo-redo to 100 steps, \emph{value 100 is hard coded in UndoMananger of openide.awt module}. Bug 50411 of NetBeans IDE bugzilla database titled as \emph{increase undo stack size}, discusses user request to increase the undo-redo maximum steps size. 3rd comment on the chain of discussion mention that NetBeans IDE used to have very large limit but that leads to large memory consumption and hence limit is placed. The discussion of the bug describes undo-redo as a possible large memory consumer if IDE is stretched with edits. 

In order to demonstrate our methodology and tool, we created a fault injected environment. We changed the limit of maximum undo-redo from 100 to $MAX_INT / 50$, number 50 being an engineering decision, allowing perpetual undo-redo operations to IDE users.  In real world IDE usage, a user will continuue edits on IDE  and IDE will store necessary information on undo and redo stacks to apply them later if undo or redo operations are performed. If IDE is used for a very long time without closing it, these stacks can grow significantly. 

UndoManager implements functionality of undo-redo and is a part of openide.awt module. The module consists of total xxxx lines of code and yyy number of tests written for the entire module. After studying the module and tests, we chose 3 tests out of yyy tests and marked these 3 tests as level 1 tests. All other tests are not labeled and hence considered as level infinity test by the method. Apart from the original NetBeans program, based on the labeled test cases, we created 1 reduced version of the program \emph{automatically} using our tool and methodology. 

In order to measure resource preservation in terms of memory by the reduced program, we need to run both the IDEs with exact same edits for same amount of time while keeping rest of the environment same. For our experiments, we created a separate ubuntu virtual box with 4GB RAM. We only installed those software and libraries needed to run the NetBeans IDE and some data collection tools that we run. While running both the IDEs, we kept only the IDE and data collection program running. In order to subject both the IDEs with consistent edits, we used Linux Desktop Projejct(ldtp) tool and send exact same edits with same amount of delays between edits. We wanted to load the IDE with large edits, we want to trigger edits that are large in numbers and size. We crated a mix of edits that consists of 60 percent of large edits, 400 character of random chunk consisting of 100 character each line sent at a time, 20 percent of medium edits, 100 character of random chunk consisting of single line, and 10 percent of small edits, 25 character of chunks, 5 percent of Ctrl+Z characters and 5 percent of Ctrl + Y characters. There is a consistent amount of delays applied after each of the edits. All the random characters are pseudo random, so as long as the seed is the same, we can repeat it for both the runs, one with original IDE and other with reduced IDE. We wrote a simple python script that will send all the edits to NetBeans IDE for a certain amount of time in a loop. 

For our experiments, we run the python script for 5 minutes and 10 minutes of time on both the original IDE and reduced IDE. ldtp sends its keystrokes very fast to IDE and hence as long as delay time is smaller, it can quickly populate the IDE with large number of edits even with very small amount of time. It is not possible to populate IDE with such a large amount of edits in 5 minutes manually. We repeated the 5 min and 10 min run on both the IDEs 5 times, while changing the seed, producing varying edits every time. We want to measure memory consumed by java objects of NetBeans IDE, NetBeans IDE itself is written in java, we used Jmap tool to measure total memory consumed by NetBeans IDE java objects. For our experiments, we start the IDE with a single open java file with single method and we populated all the edits in this method.  We called Jmap every second during our run collecting 300 data points for 5 min run and 600 data points for 10 min run. We measured average increase in memory utilization (further referred as AIMU) by NetBeans, since we start sending edits to IDE using jmap. AIMU is computed by plotting the data points collected during the experiments and averaging area under curve over time. For each of the 10 runs, AIMU by reduced version was less then AIMU by original version. For 10 min run, \emph{least possible} AIMU across 10 min runs on original program was 24.9MB, that was \emph{worse then highest possible} AIMU across 10 min runs on reduced program,19.3. For 5 min runs, these numbers were 17.56 and 14.66.  For 10 min runs, for original program, average AIMU was 29.80MB and for reduced program it was 17.61MB, reduced version preserving on average 12.19MB memory for 10 min run measuring an average 39 percent reduction in memory utilization. For 5 min run, for original program AIMU was 21.37MB and for reduced program it was 15.95MB, reduced version preserving on average 5.41 MB memory for 5 min runs measuring an average 24 percent reduction in memory utilization. 

Figure x and y demonstrate Increase in Memory Utilization(IMU) over the run of our experiments for 10 min and 5 min runs. When we study these graphs carefully,we find out that for original program IMU graph demonstrates a step pattern where memory utilization keeps increasing over the run of experiments with very few places where it goes down, while for reduced program runs, it demonstrates a more zig-zag pattern where periodically it relinquishes some of the utilized memory. 


    



   
 


   

 


