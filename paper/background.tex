\section{Background and Motivation}

We are working with a group of developers trying to build real world resource adaptive software system, the system that is being built is known as Tactical Situational Awareness System also known as SA - Situational Awareness. To demonstrate the design and implementation of resource adaptive software system, we will use location provider of SA as an example, that sends location of people or object carrying the device to some server. Location provider in case of SA consists of location, image and sometimes streaming video of the location, more complex then normal location providers where location itself is enough. Also location provider of SA can be used in extreme locations like in remote battlefield, forests or under sea where resource availability is drastically different then the environment in which SA and location provider is implemented. Devices that SA is deployed on can have very varying hardware and depending upon the the environment system is forced to use network or GPS for location. The quantity and quality of resources are not known in advance and vary drastically.

Specification of such systems are well documented and verified sometimes using a good test suite. Though, to adapt to extreme resource need some of these specifications are relaxed or compromised at run time in practice to let system function in deteriorated way. For instance, if system sends latitude, longitude, altitude and image as part of location provider, in case of low network bandwidth, system choose not to send the image, at least you know where the person or vehicle carrying the system is. Another example of adaptation can be turning off logging functionality if disk space is really low, helpful in case your disk is inside a satellite where immediate maintenance is not possible.

Component based approach to adaptive software development assumes a software system to be built of loosely connected components that are replaceable, sometimes even at run time \cite{architectureBasedAdaptation}. So, when resources are sparse or unavailable, making a particular software component unusable in its current state, system tries to swap it with a replaceable component in such a way that component and hence the system will continue to run in the changing and most often deteriorated resource environment, giving system a better chance to survive, making system more reliable.

As per objective and system evaluation of BRASS, adaptation for resources by a system can manifest itself in various ways \cite{darpa1}, the most basic being \begin{itemize}
\item Restricted functionality - Resource based adaptations will not observe certain system specifications, making system limited in its functionality. Just like low network bandwidth will trigger adaptations that will not send images.
\item Altered functionality - Resource based adaptations will observer some specifications in altered way then originally intended. In previous example, images will be send periodically while location will be sent at normal rate.
\item enhanced functionality - Resource based adaptations will meet all the specifications and may now meet some new specifications that the system was not originally implemented for. These kind of adaptations are not going to part of the discussion of this paper.  
\end{itemize}

%In this section we motivate the need of a tool that combined with test suite  can automatically produce reduced version of the components used as building block of adaptive software system. We also argue that though the tool is designed to aid building/mutating components of resource adaptive software systems, it is general tool that can be used to reduce any java program with respect to a test suite. %

As part of the BRASS effort to build industry strength resource adaptive software system that can last 100 years \cite{darpa2}, we closely work with a team of developers attempting to do so. We observed how they try build the components with possible adaptations in mind. Though authors acknowledge the lack of empirical analysis partly because unavailability of subjects as rarely systems are implemented as resource adaptive software systems, we observe that developers tend to employ two different natural strategies.

\begin{enumerate}
\item Reduction - Developers build reduced version of original components that does not observe certain less critical specifications.
\item Replacement - Developers build components that are altered from original components, new components use different libraries, data structures, hardware, resources etc.  
\end{enumerate}

Reduction makes most sense when it is possible to shield the component and in turn system by relaxing some of its specifications either by turning off some features or by not executing certain part of the code such that resource under stress will be less utilized or not utilized at all. Replacement makes most sense when it is possible to come up with completely different components using completely different libraries, hardware, data structures etc such that it will alter the resource usage also making application weather the resource degradation. Reduction associate with Restricted functionality and Replacement with altered functionality objectives mentioned by BRASS objectives as mentioned in background section. For remaining of the discussion we are only going to consider reduction strategy.   

Currently both the strategies are executed manually. A developer has to carefully observe the component, observe its resource need, consider the specifications, wrap her head around component interactions in order to come up with correct reductions. Also the reduced components have to be identified, associated with and verified against its resource consumption. They have to be verified against the \emph{new or reduced set of specifications} they are going to observe. All these steps are manual, error prone and tedious. It also triggers few cycles of development and testing. 

Is it possible to automate this process? The methodology, test suite extension and \mytool\ discussed in further sections are motivated with the intentions to (1) help developers to quickly and automatically build reduced components that can fit into resource adaptive software when reduction is the chosen adaptation. (2) If runtime adaptations are triggered and already built component is not found, system can build a new reduced component at run time.  
