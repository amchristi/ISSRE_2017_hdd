Now we describe modifications that we propose to original algorithm and intuition behind the proposals. Later during evaluation we find some evidence for the intuition. We need to put on our \emph{Resource Adaptive Software System developer} hat on to understand this modifications. As the reduced adaptive program is a useful artifact that will be used in place of the original software, we hypothesize that (a) it may not be drastically different then the original program. (b) Any reduction that does not compile is useless.

(1)  Reduction may incur many small local changes to software based on the relaxed specifications. As original HDD setups were designed to quickly converge to reduced input that is significantly \emph{smaller} then original input, they tend to make bigger chops earlier in the process. As changes to RASS are going to be local and smaller, we propose modification to original algorithm. Our algorithm always start with leaf nodes at highest depth level and it chops smallest possible unit at the beginning (statements for our tool). 

(2) Consider any two statement s1 and s2 existing at the same level in AST in the order s1,s2. Our algorithm always delete s2 before s1. Our deletions are always from right to left at same level in AST. (a) This prevents some posibilities of non compilable code and hence costly reverts, use will always be deleted before def. (b) Later read/write will be deleted before earlier read/write. Will this have better chance to keep program correct, for Alex to answer? Reverts will be needed only if any test in test suite failed.    

(3) Consider any two statements s1 and s2 existing at different level in AST such that s1 is at higher level. As our algorithm starts from leaf node and moves upward, s2 will be deleted before s1 ensuring that if def and use are at different levels, use will be deleted before def, again reducing possibility of non compilable code.  

