\section{Introduction}

Modern day software systems are very complex consisting of various resources like libraries, models, operating systems, databases, memory systems, processors drivers, browsers, services, data structures etc. While developing such complex software systems, certain implicit or explicit assumptions are made for the resources that either software is going to use or the software is going to be operated under. For example, a mobile application using location assumes that some sort of location provider services is available via network or GPS or through some other mechanism. Advances in underlying technology, sometimes continuous or sometimes drastic forces software developers to adapt/evolve their software to these underlying changes. Users of such systems have to go through updates in software or sometimes buying new technology to continue to use certain software. A change in a library used by the software sometimes forces developers to refactor or rewrite part of their software which can lead to a multiple cycles of development and testing before the application can be fully adapted to the library changes, a costly, time consuming and error prone process.  

Having a mechanism to design and implement resource adaptive real world software system that can adapt to changing environment or changing resources can solve the problem. A lot of work has been lately devoted to building self adaptive software system.s. In their survey of engineering approaches for self adaptive software systems Crupitzer et al discussed different approaches to build self adaptive software systems \cite{selfAdaptation2}.     

In order to design and implement resource adaptive software system for mission critical industry strength software system, DARPA launched Building Resource Adaptive Software System project, BRASS, that employs a new clean slate approach that aims to capture the relationship between computations and the resources they use and provide transformations that enable applications to adapt to resource changes without the need for extensive programmer involvement \cite{darpa1}. 

As per vision of BRASS, When applications adapt to resources that adaptations are manifested as (1) Restricted functionality (2) Altered functionality and (3) Enhanced functionality. We observed and worked with a team of developers trying to build resource adaptive software system and realized that developers design and implement applications react to these adaptations by reduction or replacements mostly. In reduction, the system adapt to depleted or changing resource need by reducing the application functionality, by not respecting less significant or low priority invariants while still observing significant and high priority invariants. Basically, the application continue to provide some(mostly important) functionality while avoiding exercising some features. In replacement, application adapt similarly but by changing some functionality by equivalent functionality such that resource under stress is less utilized.  

Resource adaptive software systems (RASS) are designed and implemented mostly for mission critical software systems and normally accompanied by a good test suite that captures the specifications of the system well and does a thorough job in verifying these specifications. There is a normal consensus among the developer that whenever system adapts and reduction is the chosen adaptations, it may not be able to observe all the invariants all the time. Sacrificability of specifications can be captured using a test suite by extending the test suite at test case level, at an invariant level or using some other complex combinations for reduction based adaptations. It can be as simple not exercising all the test case that exercise a single feature or turning off some asserts that verify state change of function call.  Now if we have a systematic program reducer, we can reduce the program, component, class or method automatically to adapt to resource need based on the extended test suite. 

This paper proposes a methodology to automatically create a reduced variant(s) of the program based on sacrificability of specification captured by extended test suite.  Developers can manually annotate test cases or assertions one by one or can employ some automatic mechanism to achieve these annotations. It achieves accurate program reduction by using \mytool, a new tool that we are proposing,  that combines HDD with statement deletion mutation, to automatically create this reduced variant of the program. The basic adaptation workflow is as follows. (1) Developer annotate the test suite of the program. (2) Program is deployed with its annotated test suite and newly proposed tool, \mytool\ . (3) When resource adaptation is triggered, using annotated test suite and current program, \mytool\ finds out minimal working version of the program.

This paper proposes and implements a tool, \mytool\ that takes as its input a program and an extended test suite and via reduction find out the minimal program such that all tests at certain level in extended test suite will continue to pass. The methodology and tool proposed as part of our work can be considered a step in the right direction in ensuring system reliability of mission critical system that works in an environment where resource availability is unpredictable. %Previously reduction tools have been proposed but they are mostly proposed to keep the failure or bug isolation than to produce a useful version of the program, they do not necessarily fit into or optimized for the proposed adaptation work flow. Delta-Debugging(DD) or Heirarchical Delta Debugging(HDD) are also well known reduction algorithms \cite{ddOriginal,hddOriginal}. Tools like chipperJ \cite{chipperJ} and picireny \cite{pricieley} were previous implementations of HDD that apart from reducing test input, can reduce java programs also. We will discuss advantages of our tool against these tools in related work section, most important distinction being its ability to optimally fit into adaptation workflow.  The \mytool,  as a stand alone tool,can reduce any java program given a JUnit test suite. The tool is also flexible such that by implementing an interface it can be extended to accommodate any arbitrary test suite. We have successfully used it to reduce real world android application and multiple open source java projects. Though tool was originally designed to build reduced component to aid building resource adaptive software system, it is a general purpose reduction tool that can reduce java programs using test suite. %  

Our contribution is as follows: 
\begin{enumerate}
\item We proposes a workflow that employs extended test suite, a newly developed reduction tool and existing program to automatically build adaptive program.
\item We propose test case labeling/annotations as a way to capture sacrificability of specifications.
\item We implement a stand alone reduction tool \mytool\, to build adapted version of the program using extended test suite. \footnote{our tools is available at https://github.com/amchristi/hddRASS}.
\item To demonstrate the usefulness of our methodology, we \emph{automatically} build an adaptive NetBeans IDE by just labeling 3 test cases that can reduce memory consumption significantly by sacrificing redo-undo functionality.
\item We demonstrate that \mytool\ is highly applicable, accurate and works out of the box for most of the java program setups
\item Empirical evaluation of reductions achieved using extended test suite using real world large open source programs.
\end{enumerate}      


Remaining paper is organized as follows. In section 2 we provide we describe some of the related work and how our tool differs from existing tools. In section 3 we provide background of component based approach of building adaptive software system in practice and motivation behind our approach. In section 4, we describe methodology to achieve pre-computed and run time adaptations using our tool and test case annotations. In section 5 we provide description of the tool, the theoretical aspects, practical considerations, architecture, algorithm, implementation, usage and challenges. In section 6 we evaluate the method by building adaptive NetBeans IDE that consumes less memory. Section 7 evaluates our tool and studies the reductions produced by our tool. Section 8 contains future work and conclusion.  

